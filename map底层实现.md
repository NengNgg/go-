# Map底层原理剖析
Golang中的Map的核心数据结构由 **`hmap`和`bmap`** 来实现的,如下图所示：![image](https://raw.githubusercontent.com/NengNgg/go-/master/map_picture/map1.PNG)


>图中结构体结构体是动态变化的，当发生扩容时，当产生溢出桶时等等，结构是会发生变化的。

* * *
### 初始化
```
// 初始化一个可容纳10个元素的map
info ：= make（map[string]string,10）
info ：= make（map[string]string）
var  info map[string]string
```
>**注意事项：** 如果map的初始化为nil，就不能添加原始，会直接panic；map作为函数参数时，是会影响实参的，也就是是引用类型。


* 第一步：创建一个hmap结构体对象
* 第二步：生成一个哈希因子hash0并赋值到hmap对象中（用于后续为key创建哈希值）
* 第三步：根据hint=10，并根据算法规则来创建B，当前B应该为1
```
hint        B
0~8        0
9~13      1
14~26    2
......
```

+ 第四步：根据B去创建桶（bmap对象）并存放在buckets指向的数组中，当前bmap的数量应为2
    + 当B<4时，根据B创建桶的个数的规则为：$2^{B}$
    + 当B>=4时，根据B创建桶的个数的规则为：$2^{B}$+$2^{B-4}$
> 注意：每个bmap中可以储存8个键值对，当不够储存时需要使用溢出桶，并将当前bmap中的overflow字段指向溢出桶（overfllow bucket）的位置。

* * *

### 写入数据
```
info["name"] = "重庆市"
```
在map中写入数据时，内部执行流程为：

* **第一步：** 结合哈希因子（在初始化的时候生成）和键`name`生成哈希值 `011011100011111110111011011`
* **第二步：** 获取哈希值的后B位，并根据后B位的值来决定将此键值对存放到那个桶（bmap）
* **第三步：** 在上一步确认桶之后，接下来就是在桶中写入数据。
    *   获取哈希值的tophash（即： 哈希值的`高八位`），将tophash，key，value分别写入到桶中的三个数组中，如果桶满，则通过overflow找到溢出桶，并在溢出桶中继续写入。
>注意：<u>以后在桶中寻找数据时，会基于tophash相同的key找到value</u>

*  **第四步：** hamp的个数cont++（map中的元素个数+1）

***
### 读取数据（数据定位）
```
value，ok ：=info["name"]
value := info["name"]
```
在map中读取数据，内部执行流程为：

* **第一步：** 结合哈希因子和键`name`生成哈希值
* **第二步：** 获取哈希值的后B位，并根据后B位的值来找到存放该键值对的桶
* **第三步：** 确认桶之后，根据哈希值的高8位值寻找tophash值，找到后根据tophash值的key找到value。
```
当在桶中找不到时，且overflow不为空时，再去溢出桶里找，如果有就返回，如果没有就返回数据不存在
```

* * *


### *扩容
在向map中添加数据时，当到达某个条件，则会引发字典扩容，
**装载因子：** 用来衡量引发扩容发生的动机，公式如下
>loadFactor := count / (2^B)

**触发扩容条件：**

* 装载因子>6.5,引发**翻倍扩容**。
* overflow的bucket数量过多（溢出桶使用的太多会导致map处理速度降低）。
    * B<=15，已使用的溢出桶个数>= $2^{B}$,引发**等量扩容**。
    * B>15,已使用的溢出桶个数>=$2^{15}$，引发等量扩容

>扩容的机制:如下图
![avatar](https://raw.githubusercontent.com/NengNgg/go-/master/map_picture/map2.PNG)

**注意:** 扩容后,新创建的桶里还没有数据,数据还在旧桶里,下面进行的迁移才会进行数据转移

* * *


### *迁移
就是将原来的旧桶搬到新桶里， 但是如果有大量的 key/value 需要搬迁，会非常影响性能。因此 Go map 的扩容采取了一种称为`“渐进式”`地方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 桶。

* **翻倍扩容的迁移方式：** 就是将旧桶中的数据cell（键值对）分流至新的两个桶中(比例不一定),并且编号的位置为:同编号位置 和 翻倍后对应编号位置。
    *  **首先：** 因为是翻倍扩容，则新桶的个数是旧桶的2倍，也就是说B+1（桶的个数=$2^{B}$,桶个数变成2倍，B等同+1）
    *  **然后：** 迁移时会遍历某个旧桶中所有的key（包括溢出桶），并根据key重新生成哈希值，根据哈希值的**后B位**来确定将此键值对分流到那个新桶中。
       ![avatar](https://raw.githubusercontent.com/NengNgg/go-/master/map_picture/map3.PNG)

  `扩容前的图形：`![avatar](https://raw.githubusercontent.com/NengNgg/go-/master/map_picture/map4.PNG)
  `翻倍扩容后：`![avatar](https://raw.githubusercontent.com/NengNgg/go-/master/map_picture/map5.PNG)

>因为key会发生搬迁，原来落在同一个bucket中的key，搬迁后就可以不再同一个bucket中了（bucket序列加上2^B）,而且重新开始遍历时，它是随机的键值对开始连同桶里cell都是随机选择遍历的，所以这就解释了**map为什么是无序的了。**
* **等额搬迁：** 就很简单了，由于扩容桶的数量不变，
  因此可以按序号来搬，比如原来在 0 号 bucktes，到新的地方后，仍然放在 0 号 buckets就OK了
` 等容扩容：`![avatar](https://raw.githubusercontent.com/NengNgg/go-/master/map_picture/map6.PNG)

* * *


###   遍历
>如果遍历发生在扩容迁移完之后，遍历的过程就非常简单，遍历所有的 bucket 以及它后面挂的 overflow bucket，然后挨个遍历 bucket 中的所有 cell。每个 bucket 中包含 8 个 cell，从有 key 的 cell 中取出 key 和 value，这个过程就完成了，

>但是扩容过程不是一个原子的操作，它每次最多只搬运 2 个 bucket，所以如果触发了扩容操作，那么在很长时间里，map 的状态都是处于一个中间态：有些 bucket 已经搬迁到新家，而有些 bucket 还待在老地方。因此，遍历如果发生在扩容的过程中，就会涉及到遍历新老 bucket 的过程，这是难点所在。

**遍历的大概流程是：** 根据随机生成的桶编号和cell编号开始进行遍历，通过tophash[0] 的值`是否在标志值范围内`（扩容的新的桶范围内）来确定是否迁移，如果迁移就依次遍历这个桶，如果检测到未在范围内的，就说明数据还在老桶内，数据还没有搬迁，然后就按照老桶需要搬迁分流过后到新桶内的cell数据数目遍历老桶，并不是全部遍历老桶，然后在到下一个新桶这样循环遍历。

* * *


### 删除和赋值
>删除和赋值都比较的简单,核心都是两层循环,外层遍历 bucket 和它的 overflow bucket，内层遍历整个 bucket 的各个 cell,找到key对它进行赋值或者删除,如果是删除的话,cont--,tophash还需要empty.

 ***
### 哈希冲撞和哈希函数选择

#### 哈希函数的选择
Golang 选择哈希算法时，根据 CPU 是否支持 AES 指令集进行判断 ，如果 CPU 支持 AES 指令集，则使用 Aes Hash，否则使用 memhash。

  * **AES**

HashAES 指令集全称是高级加密标准指令集（或称英特尔高级加密标准新指令，简称AES-NI），是一个 x86指令集架构的扩展，用于 Intel 和 AMD 处理器。利用 AES 指令集实现哈希算法性能很优秀，因为它能提供硬件加速。


  * **memhash**

网上没有找到这个哈希算法的作者信息，只在 Golang 的源码中有这几行注释，说它的灵感来源于 xxhash 和 cityhash

####  哈希冲撞的go处理

通常情况下，哈希算法的输入范围一定会远远大于输出范围，所以当输入的 key 足够多时一定会遇到冲突，这时就需要一些方法来解决哈希冲突问题。最常见的处理哈希冲突方法是**链地址法**和**开放地址法**。Golang 及多数编程语言都使用**链地址**法处理哈希冲突。   

  * **链地址法**   

通过前面hmap和bmap，可以看出golang使用的是`链表法`来解决哈希冲突的，每一个键值对存储的bucket的位置都是通过哈希值的后B为来确定的，所以当不同的key计算出的哈希值对于的同一个桶时，就会发生**哈希冲突**，每个bucket数组都会指向一个bmap，每个bmap最多可以存8个键值对，当发生哈希冲突时，冲突的键值对，就会被存在上一个键值对的后面。
***


学习来源：   

[Map的底层源码](https://www.bilibili.com/video/BV1Nr4y1w7aa?p=14&t=665)   

[深度解析Go语言之Map](https://www.sohu.com/a/316226634_99930294)
    
