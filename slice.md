# Slice的底层分析
切片本质上是一个结构体,它有3个字段:
```
type slice struct{
        array unsafe.Pointer //元素指针
        len int   //长度
        cap int   //容量
        
}
```
>` array：`指向底层数组；`len`（长度）：切片可用元素的个数，也就是说使用下标对slice的元素进行访问时，不能超过slice的长度，越界访问直接回发生panic，`cap`（容量）：底层数组的元素个数，cap>=len,在底层数组不进行扩容的情况下，容量也是slice可以扩张的最大限度。

* * *

#### 切片的创建

| 序号 | 方式 | 代码示例           |
| --- | --- | ---    |
| 1 | 直接声明 | var slice [ ]int  |
| 2 | new | slice :=\*new([ ]int ) |
| 3 | 字面量 | slice ：=[ ] int {1,2,3,4,5} |
| 4 | make | slice := make([ ] int, 5,10 )  |
|5| 切片或者数组“截取” |slice := array[1:5] 或    slice= : sourceSlice[1:5]|

* **直接声明**：创建出来的slice为nil，与nil相比为ture，与空切片不一样，虽然长度和容量都为0，但是所有的空切片的arry都指向同一个地址`0xc42003bda0`，空切片跟nil比较为false
* **字面量**：可以用索引号直接赋值，`未标注`的地方为0
```
s1 := [ ]int{ 0, 1, 2, 3, 8: 100}   
fmt.Println( s1, len(s1), cap(s1))
```
运行结果：
`[ 0 1 2 3 0 0 0 0 100 ]  9 9`

* **make**函数需要传入三个参数：切片类型，长度，容量。当然，容量可以不传，默认和长度相等。
* **截取：** 截取也是比较常见的一种创建 slice 的方法，可以从数组或者 slice 直接截取，当然需要指定起止索引位置
>除了表上表示的方式还有
>`slice := data [ 2:4:6 ]    // data[low, high, max]`


>其中data可以是数组也可以是切片，low为闭区间，high和max为开区间，max，high必须在老数组或者切片的cap内

* * *
#### append往数组中添加元素
`append`函数的原型：
```
func append (slice [ ]Type, elems ...Type) [ ]Type
```
>**注意：** 使用 append 可以向 slice 追加元素，实际上是往底层数组添加元素。但是底层数组的长度是固定的，如果索引 len-1 所指向的元素已经是底层数组的最后一个元素，就没法再添加了。这时，slice 会迁移到`新的内存位置`，新底层数组的长度也会增加，这样就可以放置新增的元素，同时，为了应对未来可能再次发生的 append 操作，新的底层数组的长度，也就是新 slice 的容量是留了一定的 `buffer `的。

* **slice预留buffer大小规律：** 扩容策略并不是简单的当老slice容量<1024是扩为原切片容量的 2 倍，>1024时 1.25 倍，还有内存对齐的操作。但扩容后的容量 >= 原容量的 2 倍或 1.25 倍
* **注意:** 当发生扩容迁移后，array指向的内存地址就会改变指向的底层数组，所以在对以前老的底层数组改动过，是不会影响新切片的底层数组的。

* * *
#### 切片作为函数调用参数
>slice和slice指针的区别


前面我们说到，slice 其实是一个结构体，包含了三个成员：len, cap, array。分别表示切片长度，容量，底层数据的地址。


当 slice 作为函数参数时，就是一个普通的结构体。其实很好理解：若直接传 slice，在调用者看来，实参 slice 并不会被函数中的操作改变；若传的是 slice 的指针，在调用者看来，是会被改变原 slice 的。

值的注意的是，不管传的是 slice 还是 slice 指针，如果改变了 slice 底层数组的数据，会反应到实参 slice 的底层数据。为什么能改变底层数组的数据？很好理解：底层数据在 slice 结构体里是一个指针，仅管 slice 结构体自身不会被改变，也就是说底层数据地址不会被改变。 但是通过指向底层数据的指针，可以改变切片的底层数据。

通过 slice 的 array 字段就可以拿到数组的地址。在代码里，是直接通过类似 `s[i]=10` 这种操作改变 slice 底层数组元素值。

**代码片段：**
```
package main

func main( ) {    
   s := []int{1, 1, 1}    
   f(s)  
   fmt.Println(s)
   }
   func f(s [ ]int) {    
   // i只是一个副本，不能改变s中元素的值   
   /*for _, i := range s {       
            i++   
     }   
     */   
     
   for i := range s {  
            s[i] += 1   
       }
   }
 
```
运行结果：
`[2 2 2]`


>果真改变了原始 slice 的底层数据。这里传递的是一个 slice 的副本，在 f 函数中，s 只是 main 函数中 s 的一个拷贝。在f 函数内部，对 s 的作用并不会改变外层 main 函数的 s,

>要想改变外层你slice，只有将返回的新的slice赋值到原始slice，或者向函数传递一个指向slice的指针。

#### **总结**

* 切片是对底层数组的一个抽象，描述了它的一个片段。
* 切片实际上是一个结构体，它有三个字段：长度，容量，底层数据的地址。
* 多个切片可能共享同一个底层数组，这种情况下，对其中一个切片或者底层数组的更改，会影响到其他切片。
* append 函数会在切片容量不够的情况下，会扩容并迁移到新的内存，所以会改变元素原来的位置。
* 扩容策略并不是简单的扩为原切片容量的 2 倍或 1.25 倍，还有内存对齐的操作。但是扩容后的容量 >= 原容量的 2 倍或 1.25 倍。
* 当直接用切片作为函数参数时，可以改变切片的元素，不能改变切片本身；想要改变切片本身，可以将改变后的切片返回，函数调用者`接收改变后的切片`或者将`切片指针`作为函数参数。
